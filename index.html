<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Z√ºrich Truffle Tree Finder</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='https://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üå≥</text></svg>">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    #map{height:100vh}
    #status {
      position: absolute; top: 8px; left: 8px; z-index:1000;
      background: rgba(255,255,255,0.95); padding:8px 10px;
      border-radius:5px; box-shadow:0 1px 3px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; font-size:13px;
      max-width: 320px;
    }
    .leaflet-popup-content { max-width: 320px; word-break:break-word; }
    .leaflet-popup-content-wrapper {
      border-radius: 8px;
    }
    .sticky-popup .leaflet-popup-content {
      max-height: min(70vh, 440px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
    }
    .sticky-popup .leaflet-popup-close-button {
      font-size: 22px;
      padding: 10px 12px;
      line-height: 1;
    }
    .popup-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px 12px;
      margin: 0 0 10px;
    }
    .popup-summary-item {
      background: #f9fafb;
      border-radius: 6px;
      padding: 6px 10px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-height: 52px;
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.15);
    }
    .popup-summary-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #6b7280;
    }
    .popup-summary-value {
      font-size: 14px;
      font-weight: 600;
      color: #0f172a;
      word-break: break-word;
    }
    .popup-truffle {
      border-top: 1px solid #e5e7eb;
      padding-top: 10px;
      margin-top: 6px;
      font-size: 14px;
      line-height: 1.5;
    }
    .popup-truffle-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: #d97706;
      margin-bottom: 6px;
    }
    .popup-truffle-list em {
      font-style: italic;
      font-weight: 600;
      color: #374151;
    }
    .popup-truffle-list span {
      color: #6b7280;
      font-size: 13px;
      margin-left: 4px;
    }
    .popup-truffle-list div + div {
      margin-top: 4px;
    }
    .popup-age {
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
    }
    .popup-age small {
      display: block;
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.85;
    }
    .popup-age--optimal {
      background: #dcfce7;
      color: #166534;
    }
    .popup-age--cultivar {
      background: #ede9fe;
      color: #5b21b6;
    }
    .popup-age--warning {
      background: #fef3c7;
      color: #854d0e;
    }
    
    #infoButton {
      position: absolute; top: 8px; right: 8px; z-index:1000;
      background: rgba(255,255,255,0.95); padding: 8px 12px;
      border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      font-size: 18px; font-weight: bold;
      cursor: pointer; user-select: none;
      transition: background 0.2s;
    }
    #infoButton:hover {
      background: rgba(255,255,255,1);
    }
    
    #infoModal {
      display: none;
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 2000;
      align-items: center; justify-content: center;
      padding: 20px;
    }
    #infoModal.show {
      display: flex;
    }
    
    #infoContent {
      background: white; border-radius: 8px;
      padding: 20px; max-width: 800px; max-height: 90vh;
      overflow-y: auto; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    
    #infoContent h2 {
      margin-top: 0; color: #333;
    }
    
    #infoContent table {
      width: 100%; border-collapse: collapse; margin: 15px 0;
    }
    
    #infoContent th {
      background: #f5f5f5; padding: 10px;
      text-align: left; font-weight: bold;
      border: 1px solid #ddd;
    }
    
    #infoContent td {
      padding: 10px; border: 1px solid #ddd;
      vertical-align: top;
    }
    
    #closeButton {
      float: right; background: #f0f0f0;
      border: none; border-radius: 4px;
      padding: 6px 12px; cursor: pointer;
      font-size: 14px;
    }
    #closeButton:hover {
      background: #e0e0e0;
    }
    
    #mapControls {
      position: absolute;
      bottom: 20px;
      right: 16px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }
    .map-control-button {
      background: rgba(255,255,255,0.95);
      padding: 8px 12px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, color 0.2s;
      border: none;
      min-width: 46px;
    }
    .map-control-button:hover {
      background: rgba(255,255,255,1);
    }
    .map-control-button:active {
      background: rgba(230,230,230,1);
    }
    .map-control-button.active {
      background: rgba(37,99,235,0.9);
      color: #ffffff;
    }
  </style>
</head>
<body>
  <div id="status">Initializing‚Ä¶</div>
  <div id="infoButton" title="Truffle Information">‚ÑπÔ∏è</div>
  <div id="mapControls">
    <button id="rotateButton" class="map-control-button" title="Align map with heading">üß≠</button>
    <button id="locateButton" class="map-control-button" title="Find my location">üìç</button>
  </div>
  <div id="map"></div>
  
  <div id="infoModal">
    <div id="infoContent">
      <button id="closeButton">Close</button>
      <h2>Truffle Species & Host Trees</h2>
      <table>
        <thead>
          <tr>
            <th>Truffle species</th>
            <th>Typical host trees</th>
            <th>Harvest season*</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><em>Tuber aestivum</em><br>(Summer truffle)</td>
            <td>Oak (<em>Quercus robur/petraea</em>), Hazel (<em>Corylus avellana</em>), Beech (<em>Fagus sylvatica</em>), Hornbeam (<em>Carpinus betulus</em>)</td>
            <td>May ‚Äì September</td>
          </tr>
          <tr>
            <td><em>Tuber uncinatum</em><br>(Burgundy/Autumn truffle)</td>
            <td>Oak, Hazel, Lime/Linden (<em>Tilia</em>), Hornbeam, Beech</td>
            <td>September ‚Äì December (into early winter)</td>
          </tr>
          <tr>
            <td><em>Tuber brumale</em><br>(Winter black truffle)</td>
            <td>Oak, Hazel, Linden/Hornbeam, other mixed broadleaves</td>
            <td>November ‚Äì March</td>
          </tr>
        </tbody>
      </table>
      <p style="font-size: 12px; color: #666; margin-top: 15px;">
        * Harvest seasons are approximate and can vary by location and weather conditions.
      </p>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ---------- CONFIG ----------
  const START_COORD = [47.36679, 8.50581];
  const START_ZOOM = 19;

  // WFS endpoint (base) and layer name from your GetCapabilities
  // Note: use the base URL without GetCapabilities query parameters
  const WFS_BASE = 'https://www.ogd.stadt-zuerich.ch/wfs/geoportal/Baumkataster';
  const WFS_TYPENAME = 'baumkataster_baumstandorte';
  // request outputFormat that the server advertises: application/vnd.geo+json
  const WFS_OUTPUT = 'application/vnd.geo+json';
  // srsName to request coordinates in EPSG:4326 (lat/lon)
  const WFS_SRS = 'EPSG:4326';
  // debounce milliseconds when panning/zooming
  const DEBOUNCE_MS = 250;

// ---------- MAP SETUP ----------
const map = L.map('map', {
  closePopupOnClick: false,
  closeTooltipOnClick: false,
  tapTolerance: 25,
  rotate: true
}).setView(START_COORD, START_ZOOM);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const statusEl = document.getElementById('status');

// Store location marker and circle for updates
let userMarker = null;
let userCircle = null;
const GEO_TIMEOUT_MS = 10000;
let locateRequested = false;
let locateResetTimer = null;
let activePopup = null;
let allowBackgroundPopupClose = false;
let rotateActive = false;
let orientationHandler = null;
let orientationLastHeading = null;
let orientationPermissionDenied = false;
let orientationInProgress = false;
let orientationLastUpdate = 0;

// Geolocation requests are triggered via the üìç button to satisfy browser permission requirements.

// When location is found, add a marker
map.on('locationfound', (e) => {
  if (!locateRequested) {
    return;
  }
  locateRequested = false;
  if (locateResetTimer) {
    clearTimeout(locateResetTimer);
    locateResetTimer = null;
  }
  locateButton.textContent = 'üìç';
  // Remove old marker if exists
  if (userMarker) map.removeLayer(userMarker);
  if (userCircle) map.removeLayer(userCircle);
  
  const radius = e.accuracy / 2;

  // Add marker
  userMarker = L.marker(e.latlng)
    .addTo(map)
    .bindPopup(`You are within ${Math.round(radius)} meters from this point`, {
      closeOnClick: false,
      className: 'sticky-popup'
    });

  // Add accuracy circle
  userCircle = L.circle(e.latlng, {
    radius: radius,
    color: '#136aec',
    fillColor: '#136aec',
    fillOpacity: 0.2
  }).addTo(map);

  const currentZoom = map.getZoom();
  const desiredZoom = currentZoom < 17 ? 17 : currentZoom;
  map.setView(e.latlng, desiredZoom);
});

// When location access is denied or fails
map.on('locationerror', (e) => {
  if (!locateRequested) {
    return;
  }
  locateRequested = false;
  if (locateResetTimer) {
    clearTimeout(locateResetTimer);
    locateResetTimer = null;
  }
  console.warn("Geolocation failed:", e.message);
  statusEl.textContent = "Could not determine your location.";
  locateButton.textContent = '‚ùå';
  setTimeout(() => {
    locateButton.textContent = 'üìç';
  }, 2000);
});

// Keep popups interactive on touch devices without immediately closing
map.on('popupopen', (e) => {
  activePopup = e.popup;
  allowBackgroundPopupClose = false;
  const popupEl = e.popup.getElement();
  if (popupEl) {
    L.DomEvent.disableClickPropagation(popupEl);
    L.DomEvent.disableScrollPropagation(popupEl);

    // Prevent the close button from being swallowed by the propagation guard
    const closeBtn = popupEl.querySelector('.leaflet-popup-close-button');
    if (closeBtn) {
      L.DomEvent.disableClickPropagation(closeBtn);
    }
  }

  // Allow outside taps to close after the opening interaction finishes
  setTimeout(() => {
    allowBackgroundPopupClose = true;
  }, 150);
});

map.on('popupclose', () => {
  activePopup = null;
  allowBackgroundPopupClose = false;
});

function eventTargetsPopup(originalEvent) {
  if (!originalEvent) return false;
  const classesToMatch = ['leaflet-popup', 'leaflet-popup-content', 'leaflet-popup-content-wrapper'];
  if (typeof originalEvent.composedPath === 'function') {
    const path = originalEvent.composedPath();
    if (Array.isArray(path)) {
      return path.some(node => {
        if (!node || !node.classList) return false;
        return classesToMatch.some(cls => node.classList.contains(cls));
      });
    }
  }
  let target = originalEvent.target || originalEvent.srcElement;
  while (target) {
    if (target.classList && classesToMatch.some(cls => target.classList.contains(cls))) {
      return true;
    }
    if (typeof target.closest === 'function') {
      const popupAncestor = target.closest('.leaflet-popup');
      if (popupAncestor) return true;
    }
    target = target.parentNode;
  }
  return false;
}

function handleBackgroundPopupClose(e) {
  if (!activePopup || !allowBackgroundPopupClose) {
    return;
  }
  const originalEvent = e.originalEvent || e;
  if (eventTargetsPopup(originalEvent)) {
    return;
  }
  allowBackgroundPopupClose = false;
  map.closePopup(activePopup);
}

map.on('click', handleBackgroundPopupClose);
map.on('touchstart', handleBackgroundPopupClose);
map.on('contextmenu', handleBackgroundPopupClose);

function supportsMapRotation(){
  return typeof map.setBearing === 'function';
}

function supportsDeviceOrientation(){
  return typeof window !== 'undefined' && 'DeviceOrientationEvent' in window;
}

function normalizeHeading(value){
  if (typeof value !== 'number' || Number.isNaN(value)) return null;
  let heading = value % 360;
  if (heading < 0) heading += 360;
  return heading;
}

function headingDelta(a,b){
  if (a === null || b === null) return Infinity;
  const diff = Math.abs(a - b) % 360;
  return diff > 180 ? 360 - diff : diff;
}

function extractHeading(event){
  if (!event) return null;
  if (typeof event.webkitCompassHeading === 'number') {
    return normalizeHeading(event.webkitCompassHeading);
  }
  if (typeof event.compassHeading === 'number') {
    return normalizeHeading(event.compassHeading);
  }
  if (typeof event.alpha === 'number') {
    return normalizeHeading(event.alpha);
  }
  if (typeof event.heading === 'number') {
    return normalizeHeading(event.heading);
  }
  return null;
}

function applyHeadingToMap(heading){
  if (!supportsMapRotation()) return;
  try {
    map.setBearing(heading, { animate: false });
  } catch (err) {
    console.warn('Map bearing update failed', err);
  }
}

function attachOrientationListener(){
  if (orientationHandler) return true;
  const handler = (event) => {
    const heading = extractHeading(event);
    if (heading === null) return;
    const now = Date.now();
    const delta = headingDelta(orientationLastHeading, heading);
    if (delta < 1 && now - orientationLastUpdate < 120) return;
    orientationLastHeading = heading;
    orientationLastUpdate = now;
    applyHeadingToMap(heading);
  };
  window.addEventListener('deviceorientationabsolute', handler, true);
  window.addEventListener('deviceorientation', handler, true);
  orientationHandler = handler;
  return true;
}

function detachOrientationListener(){
  if (!orientationHandler) return;
  window.removeEventListener('deviceorientationabsolute', orientationHandler, true);
  window.removeEventListener('deviceorientation', orientationHandler, true);
  orientationHandler = null;
}

async function enableHeadingFollow(){
  if (orientationInProgress) return false;
  orientationInProgress = true;

  if (!supportsMapRotation()) {
    orientationInProgress = false;
    statusEl.textContent = 'Map rotation not supported in this browser.';
    return false;
  }

  if (!supportsDeviceOrientation()) {
    orientationInProgress = false;
    statusEl.textContent = 'Compass data not available on this device.';
    return false;
  }

  if (orientationPermissionDenied) {
    orientationInProgress = false;
    statusEl.textContent = 'Compass access previously denied.';
    return false;
  }

  let permissionGranted = true;
  if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission === 'function') {
    try {
      const response = await window.DeviceOrientationEvent.requestPermission();
      permissionGranted = response === 'granted';
    } catch (err) {
      console.warn('Device orientation permission error', err);
      permissionGranted = false;
    }
  }

  if (!permissionGranted) {
    orientationPermissionDenied = true;
    orientationInProgress = false;
    statusEl.textContent = 'Compass permission denied.';
    return false;
  }

  attachOrientationListener();
  orientationInProgress = false;
  statusEl.textContent = 'Heading lock enabled.';
  return true;
}

function disableHeadingFollow(resetBearing = true, notify = true){
  detachOrientationListener();
  orientationLastHeading = null;
  orientationLastUpdate = 0;
  if (resetBearing && supportsMapRotation()) {
    try {
      map.setBearing(0, { animate: true });
    } catch (err) {
      map.setBearing(0);
    }
  }
  if (notify) {
    statusEl.textContent = 'Heading lock disabled.';
  }
}

  // Create custom shape markers
  function createShapeMarker(latlng, color, shape, isIdeal = false, isCultivar = false) {
    const size = 12;
    const svgShapes = {
      circle: `<circle cx="12" cy="12" r="8" fill="${color}" stroke="white" stroke-width="2"/>`,
      square: `<rect x="6" y="6" width="12" height="12" fill="${color}" stroke="white" stroke-width="2"/>`,
      triangle: `<polygon points="12,4 20,18 4,18" fill="${color}" stroke="white" stroke-width="2"/>`,
      pentagon: `<polygon points="12,3 21,9 18,19 6,19 3,9" fill="${color}" stroke="white" stroke-width="2"/>`,
      diamond: `<polygon points="12,2 22,12 12,22 2,12" fill="${color}" stroke="white" stroke-width="2"/>`,
      star: `<polygon points="12,2 14.5,9 22,9 16,14 18,22 12,17 6,22 8,14 2,9 9.5,9" fill="${color}" stroke="white" stroke-width="2"/>`,
      starLarge: `<polygon points="12,2 14.5,9 22,9 16,14 18,22 12,17 6,22 8,14 2,9 9.5,9" fill="${color}" stroke="white" stroke-width="2.5"/>`
    };
    
    // Use star shape for ideal age trees
    let finalShape = isIdeal ? 'star' : shape;
    let iconSize = [24, 24];
    
    // Wild-type (native) in ideal age: larger black star
    if (isIdeal && !isCultivar) {
      finalShape = 'starLarge';
      iconSize = [30, 30]; // Bigger for wild-type
      color = '#000000'; // Black for wild-type
    } else if (isIdeal && isCultivar) {
      // Cultivar in ideal age: keep purple star at normal size
      color = '#8b4789'; // Purple for all cultivars
    }
    
    const svgIcon = L.divIcon({
      html: `<svg width="${iconSize[0]}" height="${iconSize[1]}" viewBox="0 0 24 24">${svgShapes[finalShape] || svgShapes.circle}</svg>`,
      className: 'custom-marker',
      iconSize: iconSize,
      iconAnchor: [iconSize[0]/2, iconSize[1]/2]
    });
    
    return L.marker(latlng, { icon: svgIcon });
  }

  // layer to hold current WFS features
  let wfsLayer = L.geoJSON(null, {
    onEachFeature(feature, layer) {
      const props = feature.properties || {};
      layer.bindPopup(buildPopup(props), {
        autoClose: true,
        closeButton: true,
        closeOnClick: false,
        className: 'sticky-popup'
      });
      
      // Store feature data for filtering
      layer.feature = feature;
    },
    pointToLayer(feature, latlng) {
      const props = feature.properties || {};
      const truffleSpecies = getTruffleSpecies(props);
      
      if (truffleSpecies) {
        // Check if tree is in ideal age range
        const age = getTreeAge(props);
        const ideal = isIdealAge(truffleSpecies, age);
        
        // Truffle-compatible species: custom shape marker with species color
        // Use star shape if in ideal age range
        // Wild-type (native) gets black star, cultivars get purple star
        return createShapeMarker(latlng, truffleSpecies.color, truffleSpecies.shape, ideal, truffleSpecies.isCultivar);
      } else {
        // Default: faint grey circle marker for all other trees
        return L.circleMarker(latlng, { 
          radius: 5, 
          fillColor: '#cccccc', 
          color: '#999999', 
          weight: 1, 
          fillOpacity: 0.4 
        });
      }
    }
  }).addTo(map);

  // ---------- HELPERS ----------
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), ms); }; }

  // Truffle-compatible species detection and color mapping with ideal age ranges
  const TRUFFLE_SPECIES = {
    // Oak (Eiche) - Circle - ideal: 30-80 years
    'Quercus robur': { color: '#8b4789', name: 'Oak', shape: 'circle', order: 1, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    'Quercus petraea': { color: '#8b4789', name: 'Oak', shape: 'circle', order: 1, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    // Hazel (Hasel) - Square - ideal: 15-30 years
    'Corylus avellana': { color: '#4575b4', name: 'Hazel', shape: 'square', order: 2, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 15, maxAge: 30 },
    // Beech (Buche) - Triangle - ideal: 30-80 years
    'Fagus sylvatica': { color: '#1a9850', name: 'Beech', shape: 'triangle', order: 3, truffles: ['aestivum', 'uncinatum'], minAge: 30, maxAge: 80 },
    // Hornbeam (Hainbuche) - Pentagon - ideal: 30-80 years
    'Carpinus betulus': { color: '#d95f02', name: 'Hornbeam', shape: 'pentagon', order: 4, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    // Linden (Linde) - Diamond - ideal: 30-80 years
    'Tilia cordata': { color: '#fee08b', name: 'Linden', shape: 'diamond', order: 5, truffles: ['uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    'Tilia platyphyllos': { color: '#fee08b', name: 'Linden', shape: 'diamond', order: 5, truffles: ['uncinatum', 'brumale'], minAge: 30, maxAge: 80 }
  };
  


  function isCultivar(latinName) {
    // Check if the name contains cultivar indicators (quotes, 'cv.', 'var.', etc.)
    return latinName.includes("'") || latinName.includes('"') || 
           latinName.includes('cv.') || latinName.includes('var.') ||
           latinName.includes('cultivar') || latinName.includes('subsp.');
  }

  function getTruffleSpecies(props) {
    if (!props || !props.baumnamelat) return null;
    const latinName = props.baumnamelat.trim();
    
    // Check for exact match first
    if (TRUFFLE_SPECIES[latinName]) {
      const speciesInfo = { ...TRUFFLE_SPECIES[latinName] };
      speciesInfo.isCultivar = false;
      return speciesInfo;
    }
    
    // Check if latin name starts with any of our species (handles cultivars)
    for (const [species, info] of Object.entries(TRUFFLE_SPECIES)) {
      if (latinName.startsWith(species)) {
        const speciesInfo = { ...info };
        speciesInfo.isCultivar = isCultivar(latinName);
        return speciesInfo;
      }
    }
    
    return null;
  }
  
  function getTreeAge(props) {
    if (!props || !props.pflanzjahr) return null;
    const plantYear = parseInt(props.pflanzjahr);
    if (isNaN(plantYear) || plantYear <= 0) return null;
    return new Date().getFullYear() - plantYear;
  }
  
  function isIdealAge(truffleSpecies, age) {
    if (!truffleSpecies || age === null) return false;
    return age >= truffleSpecies.minAge && age <= truffleSpecies.maxAge;
  }
  


  function fmtValue(value){
    if (value === null || value === undefined || value === '') return '‚Äî';
    return escapeHtml(String(value));
  }

  // Truffle species info with seasons
  const TRUFFLE_INFO = {
    'aestivum': { name: 'Tuber aestivum', common: 'Summer truffle', months: 'May-Sep' },
    'uncinatum': { name: 'Tuber uncinatum', common: 'Burgundy/Autumn truffle', months: 'Sep-Dec' },
    'brumale': { name: 'Tuber brumale', common: 'Winter black truffle', months: 'Nov-Mar' }
  };

  const SUMMARY_FIELDS = [
    { key: 'baumnummer', label: 'Baumnummer' },
    { key: 'baumnamelat', label: 'Latin name' },
    { key: 'baumnamedeu', label: 'German name' },
    { key: 'kronendurchmesser', label: 'Kronendurchmesser' },
    { key: 'pflanzjahr', label: 'Pflanzjahr' }
  ];

  function buildPopup(props){
    const summaryGrid = SUMMARY_FIELDS.map(({ key, label }) => {
      let val = props && (key in props) ? props[key] : '‚Äî';
      if (key === 'kronendurchmesser' && val !== '‚Äî') {
        val = `${val} m`;
      }
      return `
        <div class="popup-summary-item">
          <div class="popup-summary-label">${escapeHtml(label)}</div>
          <div class="popup-summary-value">${fmtValue(val)}</div>
        </div>`;
    }).join('');

    // Check if this is a truffle-compatible species
    const truffleSpecies = getTruffleSpecies(props);
    let truffleInfo = '';
    
    if (truffleSpecies && truffleSpecies.truffles && truffleSpecies.truffles.length > 0) {
      const truffleList = truffleSpecies.truffles.map(t => {
        const info = TRUFFLE_INFO[t];
        return `<div><em>${escapeHtml(info.name)}</em><span>(${escapeHtml(info.months)})</span></div>`;
      }).join('');
      
      // Calculate age and check if ideal
      const age = getTreeAge(props);
      const ideal = isIdealAge(truffleSpecies, age);
      const ageText = age !== null ? `${age} years old` : 'unknown age';
      const ageRangeText = `${truffleSpecies.minAge}-${truffleSpecies.maxAge} years`;
      
      let ageStatus = '';
      if (age !== null) {
        if (ideal) {
          if (truffleSpecies.isCultivar) {
            ageStatus = `<div class="popup-age popup-age--cultivar">
              ‚≠ê <strong>Ideal age for truffles</strong> (${escapeHtml(ageText)}, ideal: ${escapeHtml(ageRangeText)})
              <small>‚ö†Ô∏è Cultivar: less optimal than wild-type for truffle production</small>
            </div>`;
          } else {
            ageStatus = `<div class="popup-age popup-age--optimal">
              ‚≠ê <strong>OPTIMAL for truffles!</strong> (${escapeHtml(ageText)}, ideal: ${escapeHtml(ageRangeText)})
              <small>‚úì Wild-type / Native species</small>
            </div>`;
          }
        } else {
          const cultivarNote = truffleSpecies.isCultivar ? '<small>Note: Cultivar variety</small>' : '';
          ageStatus = `<div class="popup-age popup-age--warning">
            Age: ${escapeHtml(ageText)} (ideal: ${escapeHtml(ageRangeText)})
            ${cultivarNote}
          </div>`;
        }
      }
      
      truffleInfo = `
        <div class="popup-truffle">
          <div class="popup-truffle-title">üçÑ Truffle Host</div>
          <div class="popup-truffle-list">${truffleList}</div>
          ${ageStatus}
        </div>`;
    }

    return `
      <div>
        <div class="popup-summary-grid">${summaryGrid}</div>
        ${truffleInfo}
      </div>`;
  }

  // Build WFS GetFeature URL for the current bbox. For WFS 1.1.0 bbox order is minx,miny,maxx,maxy
  function buildWfsUrl(bboxStr){
    // bboxStr from Leaflet is "minLng,minLat,maxLng,maxLat"
    const params = new URLSearchParams({
      service: 'WFS',
      version: '1.1.0',
      request: 'GetFeature',
      typeName: WFS_TYPENAME,
      outputFormat: WFS_OUTPUT,
      srsName: WFS_SRS,
      bbox: bboxStr + ',' + WFS_SRS
    });
    return `${WFS_BASE}?${params.toString()}`;
  }

  // Load features for current map view
  async function loadFeaturesForView(){
    const bounds = map.getBounds();
    const bboxStr = bounds.toBBoxString(); // "minLng,minLat,maxLng,maxLat"
    const url = buildWfsUrl(bboxStr);
    statusEl.textContent = 'Fetching features for current view‚Ä¶';
    try {
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      // server responds with GeoJSON when using application/vnd.geo+json
      const geojson = await resp.json();
      // clear and add
      wfsLayer.clearLayers();
      // If server returns features in a property other than "features", try to handle gracefully
      if (geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)) {
        wfsLayer.addData(geojson);
        statusEl.textContent = `Loaded ${geojson.features.length} total trees`;
      } else if (geojson.features && Array.isArray(geojson.features)) {
        wfsLayer.addData(geojson.features);
        statusEl.textContent = `Loaded ${geojson.features.length} total trees`;
      } else {
        // unexpected response; show raw
        console.warn('Unexpected GeoJSON shape', geojson);
        statusEl.textContent = 'Loaded (unexpected response shape) ‚Äî check console';
      }
    } catch (err) {
      console.error('WFS fetch failed', err);
      statusEl.innerHTML = `Failed to load WFS: ${escapeHtml(err.message)}<br><small>(Check console for details)</small>`;
    }
  }

  const debouncedLoad = debounce(loadFeaturesForView, DEBOUNCE_MS);

  // ---------- INITIAL LOAD & EVENTS ----------
  map.on('moveend', debouncedLoad);
  map.on('zoomend', debouncedLoad);

  // Load initial features after a short delay to ensure map is fully initialized
  setTimeout(loadFeaturesForView, 100);

  // Also allow zoom-to and reload by double-clicking the status box (handy for dev)
  statusEl.title = 'Double-click to reload WFS for current view';
  statusEl.ondblclick = () => debouncedLoad();

  // ---------- INFO MODAL ----------
  const infoButton = document.getElementById('infoButton');
  const infoModal = document.getElementById('infoModal');
  const closeButton = document.getElementById('closeButton');

  infoButton.onclick = () => {
    infoModal.classList.add('show');
  };

  closeButton.onclick = () => {
    infoModal.classList.remove('show');
  };

  // Close modal when clicking outside content
  infoModal.onclick = (e) => {
    if (e.target === infoModal) {
      infoModal.classList.remove('show');
    }
  };

  // ---------- LOCATE BUTTON ----------
  const rotateButton = document.getElementById('rotateButton');
  const locateButton = document.getElementById('locateButton');

  rotateButton.onclick = async () => {
    if (orientationInProgress) {
      return;
    }

    if (rotateActive) {
      rotateActive = false;
      rotateButton.classList.remove('active');
      rotateButton.textContent = 'üß≠';
      disableHeadingFollow(true);
      return;
    }

  rotateButton.textContent = '‚è≥';
  rotateButton.disabled = true;
  const enabled = await enableHeadingFollow();
  rotateButton.disabled = false;

    if (enabled) {
      rotateActive = true;
      rotateButton.classList.add('active');
      rotateButton.textContent = 'üß≠‚Üª';
    } else {
      rotateActive = false;
      rotateButton.classList.remove('active');
      rotateButton.textContent = 'üß≠';
      disableHeadingFollow(true, false);
    }
  };
  
  locateButton.onclick = () => {
    if (locateRequested) {
      return;
    }
    locateRequested = true;
    locateButton.textContent = '‚è≥';

    if (locateResetTimer) {
      clearTimeout(locateResetTimer);
      locateResetTimer = null;
    }

    map.locate({
      setView: false,
      enableHighAccuracy: true,
      timeout: GEO_TIMEOUT_MS,
      watch: false
    });
    
    locateResetTimer = setTimeout(() => {
      if (locateButton.textContent === '‚è≥') {
        locateButton.textContent = 'üìç';
      }
      locateRequested = false;
    }, GEO_TIMEOUT_MS + 1000);
  };

  </script>
</body>
</html>