<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Z√ºrich Truffle Tree Finder</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='https://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üå≥</text></svg>">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    #map{height:100vh}
    #status {
      position: absolute; top: 8px; left: 56px; z-index:1000;
      background: rgba(255,255,255,0.95); padding:8px 10px;
      border-radius:5px; box-shadow:0 1px 3px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; font-size:13px;
      max-width: min(320px, calc(100vw - 96px));
      transition: background 0.2s, color 0.2s;
    }
    #status.error {
      background: #fee2e2;
      color: #991b1b;
    }
    #status.success {
      background: #dcfce7;
      color: #166534;
    }
    .leaflet-popup-content { max-width: 320px; word-break:break-word; }
    .leaflet-popup-content-wrapper {
      border-radius: 8px;
    }
    .sticky-popup .leaflet-popup-content {
      max-height: min(70vh, 440px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
    }
    .sticky-popup .leaflet-popup-close-button {
      font-size: 22px;
      padding: 10px 12px;
      line-height: 1;
    }
    .popup-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 6px 8px;
      margin: 0 0 8px;
    }
    .popup-summary-item {
      background: #f3f4f6;
      border-radius: 5px;
      padding: 6px 8px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
    }
    .popup-summary-label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: #4b5563;
      text-transform: uppercase;
    }
    .popup-summary-value {
      font-size: 13px;
      font-weight: 600;
      color: #111827;
      word-break: break-word;
    }
    .popup-truffle {
      border-top: 1px solid #e5e7eb;
      padding-top: 10px;
      margin-top: 6px;
      font-size: 14px;
      line-height: 1.5;
    }
    .popup-truffle-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: #d97706;
      margin-bottom: 6px;
    }
    .popup-truffle-list em {
      font-style: italic;
      font-weight: 600;
      color: #374151;
    }
    .popup-truffle-list span {
      color: #6b7280;
      font-size: 13px;
      margin-left: 4px;
    }
    .popup-truffle-list div + div {
      margin-top: 4px;
    }
    .popup-age {
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
    }
    .popup-age small {
      display: block;
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.85;
    }
    .popup-age--optimal {
      background: #dcfce7;
      color: #166534;
    }
    .popup-age--cultivar {
      background: #ede9fe;
      color: #5b21b6;
    }
    .popup-age--warning {
      background: #fef3c7;
      color: #854d0e;
    }
    
    #infoButton {
      position: absolute; top: 8px; right: 8px; z-index:1000;
      background: rgba(255,255,255,0.95); padding: 8px 12px;
      border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      font-size: 18px; font-weight: bold;
      cursor: pointer; user-select: none;
      transition: background 0.2s;
    }
    #infoButton:hover {
      background: rgba(255,255,255,1);
    }
    
    #infoModal {
      display: none;
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 2000;
      align-items: center; justify-content: center;
      padding: 20px;
    }
    #infoModal.show {
      display: flex;
    }
    
    #infoContent {
      background: white; border-radius: 8px;
      padding: 20px; max-width: 800px; max-height: 90vh;
      overflow-y: auto; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    
    #infoContent h2 {
      margin-top: 0; color: #333;
    }
    
    #infoContent table {
      width: 100%; border-collapse: collapse; margin: 15px 0;
    }
    
    #infoContent th {
      background: #f5f5f5; padding: 10px;
      text-align: left; font-weight: bold;
      border: 1px solid #ddd;
    }
    
    #infoContent td {
      padding: 10px; border: 1px solid #ddd;
      vertical-align: top;
    }
    
    #closeButton {
      float: right; background: #f0f0f0;
      border: none; border-radius: 4px;
      padding: 6px 12px; cursor: pointer;
      font-size: 14px;
    }
    #closeButton:hover {
      background: #e0e0e0;
    }
    
    #mapControls {
      position: absolute;
      bottom: 20px;
      right: 16px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }
    .map-control-button {
      background: rgba(255,255,255,0.95);
      padding: 8px 12px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, color 0.2s;
      border: none;
      min-width: 46px;
    }
    .map-control-button:hover {
      background: rgba(255,255,255,1);
    }
    .map-control-button:active {
      background: rgba(230,230,230,1);
    }
    .map-control-button.active {
      background: rgba(37,99,235,0.9);
      color: #ffffff;
    }
    .map-control-button:disabled,
    .map-control-button.disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background: rgba(229,231,235,0.9);
      color: #4b5563;
    }
    #searchContainer {
      position: absolute;
      bottom: 20px;
      left: 8px;
      top: auto;
      right: auto;
      z-index: 1000;
      width: min(320px, calc(100vw - 120px));
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    #searchInput {
      width: 100%;
      padding: 8px 34px 8px 10px;
      border-radius: 5px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      font-size: 13px;
      background: rgba(255,255,255,0.95);
      transition: border 0.2s, box-shadow 0.2s;
    }
    #searchInput:focus {
      outline: none;
      border-color: rgba(37, 99, 235, 0.6);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }
    #searchResults {
      margin-top: 6px;
      background: rgba(255,255,255,0.97);
      border-radius: 6px;
      box-shadow: 0 4px 10px rgba(15,23,42,0.15);
      max-height: 260px;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.35);
      display: none;
    }
    #searchResults.show {
      display: block;
    }
    .search-result {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
      padding: 8px 10px;
      border: none;
      background: transparent;
      cursor: pointer;
      text-align: left;
      font-family: inherit;
      font-size: 13px;
      border-bottom: 1px solid rgba(226, 232, 240, 0.9);
      transition: background 0.15s;
    }
    .search-result:last-child {
      border-bottom: none;
    }
    .search-result:hover,
    .search-result:focus {
      background: rgba(37, 99, 235, 0.08);
      outline: none;
    }
    .search-result-title {
      font-weight: 600;
      color: #0f172a;
    }
    .search-result-subtitle {
      font-size: 12px;
      color: #475569;
      margin-top: 2px;
    }
    .search-empty {
      padding: 10px;
      font-size: 12px;
      color: #6b7280;
    }
    .search-info {
      padding: 10px;
      font-size: 11px;
      color: #475569;
      background: rgba(248,250,252,0.9);
    }
    @media (max-width: 600px) {
      #searchContainer {
        left: 8px;
        right: auto;
        bottom: 20px;
        width: calc(100vw - 120px);
      }
      #status {
        left: 8px;
        right: 8px;
      }
    }
  </style>
</head>
<body>
  <div id="status">Initializing‚Ä¶</div>
  <div id="searchContainer">
    <input id="searchInput" type="search" placeholder="Search trees in view‚Ä¶" autocomplete="off" spellcheck="false" aria-label="Search trees in view"/>
    <div id="searchResults"></div>
  </div>
  <div id="infoButton" title="Truffle Information">‚ÑπÔ∏è</div>
  <div id="mapControls">
    <button id="locateButton" class="map-control-button" title="Find my location">üìç</button>
  </div>
  <div id="map"></div>
  
  <div id="infoModal">
    <div id="infoContent">
      <button id="closeButton">Close</button>
      <h2>Truffle Species & Host Trees</h2>
      <table>
        <thead>
          <tr>
            <th>Truffle species</th>
            <th>Typical host trees</th>
            <th>Harvest season*</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><em>Tuber aestivum</em><br>(Summer truffle)</td>
            <td>Oak (<em>Quercus robur/petraea</em>), Hazel (<em>Corylus avellana</em>), Beech (<em>Fagus sylvatica</em>), Hornbeam (<em>Carpinus betulus</em>)</td>
            <td>May ‚Äì September</td>
          </tr>
          <tr>
            <td><em>Tuber uncinatum</em><br>(Burgundy/Autumn truffle)</td>
            <td>Oak, Hazel, Lime/Linden (<em>Tilia</em>), Hornbeam, Beech</td>
            <td>September ‚Äì December (into early winter)</td>
          </tr>
          <tr>
            <td><em>Tuber brumale</em><br>(Winter black truffle)</td>
            <td>Oak, Hazel, Linden/Hornbeam, other mixed broadleaves</td>
            <td>November ‚Äì March</td>
          </tr>
        </tbody>
      </table>
      <p style="font-size: 12px; color: #666; margin-top: 15px;">
        * Harvest seasons are approximate and can vary by location and weather conditions.
      </p>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ---------- CONFIG ----------
  const START_COORD = [47.37, 8.514];
  const START_ZOOM = 16;

  // WFS endpoint (base) and layer name from your GetCapabilities
  // Note: use the base URL without GetCapabilities query parameters
  const WFS_BASE = 'https://www.ogd.stadt-zuerich.ch/wfs/geoportal/Baumkataster';
  const WFS_TYPENAME = 'baumkataster_baumstandorte';
  // request outputFormat that the server advertises: application/vnd.geo+json
  const WFS_OUTPUT = 'application/vnd.geo+json';
  // srsName to request coordinates in EPSG:4326 (lat/lon)
  const WFS_SRS = 'EPSG:4326';
  // debounce milliseconds when panning/zooming
  const DEBOUNCE_MS = 250;

// ---------- MAP SETUP ----------
const map = L.map('map', {
  closePopupOnClick: false,
  closeTooltipOnClick: false,
  tapTolerance: 25
}).setView(START_COORD, START_ZOOM);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 20,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const statusEl = document.getElementById('status');
const searchContainer = document.getElementById('searchContainer');
const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const lastSearchMatches = new Map();
const SEARCH_RESULTS_LIMIT = 40;
let activeFeatureKey = null;
let suppressActiveFeatureReset = false;
const debouncedUpdateSearch = debounce(() => updateSearchResults(), 150);

// Store location marker and circle for updates
let userMarker = null;
let userCircle = null;
const GEO_TIMEOUT_MS = 10000;
let locateRequested = false;
let locateResetTimer = null;
let activePopup = null;
let allowBackgroundPopupClose = false;
let statusTimer = null;

function updateStatus(message, { type = 'info', sticky = false, allowHtml = false } = {}) {
  if (!statusEl) return;
  if (statusTimer) {
    clearTimeout(statusTimer);
    statusTimer = null;
  }

  statusEl.classList.remove('error', 'success');
  if (type === 'error') {
    statusEl.classList.add('error');
  } else if (type === 'success') {
    statusEl.classList.add('success');
  }

  if (allowHtml) {
    statusEl.innerHTML = message;
  } else {
    statusEl.textContent = message;
  }

  if (!sticky) {
    statusTimer = setTimeout(() => {
      statusEl.textContent = 'Ready';
      statusEl.classList.remove('error', 'success');
      statusTimer = null;
    }, 5000);
  }
}

function warnOnce(key, ...args) {
  if (!warnOnce.cache.has(key)) {
    console.warn(...args);
    warnOnce.cache.add(key);
  }
}
warnOnce.cache = new Set();

// Geolocation requests are triggered via the üìç button to satisfy browser permission requirements.

// When location is found, add a marker
map.on('locationfound', (e) => {
  if (!locateRequested) {
    return;
  }
  locateRequested = false;
  if (locateResetTimer) {
    clearTimeout(locateResetTimer);
    locateResetTimer = null;
  }
  locateButton.textContent = 'üìç';
  updateStatus('Location pinpointed.', { type: 'success' });
  // Remove old marker if exists
  if (userMarker) map.removeLayer(userMarker);
  if (userCircle) map.removeLayer(userCircle);
  
  const radius = e.accuracy / 2;

  // Add marker
  userMarker = L.marker(e.latlng)
    .addTo(map)
    .bindPopup(`You are within ${Math.round(radius)} meters from this point`, {
      closeOnClick: false,
      className: 'sticky-popup'
    });

  // Add accuracy circle
  userCircle = L.circle(e.latlng, {
    radius: radius,
    color: '#136aec',
    fillColor: '#136aec',
    fillOpacity: 0.2
  }).addTo(map);

  const currentZoom = map.getZoom();
  const desiredZoom = currentZoom < 17 ? 17 : currentZoom;
  map.setView(e.latlng, desiredZoom);
});

// When location access is denied or fails
map.on('locationerror', (e) => {
  if (!locateRequested) {
    return;
  }
  locateRequested = false;
  if (locateResetTimer) {
    clearTimeout(locateResetTimer);
    locateResetTimer = null;
  }
  console.warn("Geolocation failed:", e.message);
  updateStatus('Could not determine your location.', { type: 'error', sticky: true });
  locateButton.textContent = '‚ùå';
  setTimeout(() => {
    locateButton.textContent = 'üìç';
  }, 2000);
});

// Keep popups interactive on touch devices without immediately closing
map.on('popupopen', (e) => {
  activePopup = e.popup;
  allowBackgroundPopupClose = false;
  const popupEl = e.popup.getElement();
  if (popupEl) {
    L.DomEvent.disableClickPropagation(popupEl);
    L.DomEvent.disableScrollPropagation(popupEl);

    // Prevent the close button from being swallowed by the propagation guard
    const closeBtn = popupEl.querySelector('.leaflet-popup-close-button');
    if (closeBtn) {
      L.DomEvent.disableClickPropagation(closeBtn);
    }
  }

  // Allow outside taps to close after the opening interaction finishes
  setTimeout(() => {
    allowBackgroundPopupClose = true;
  }, 150);
});

map.on('popupclose', () => {
  activePopup = null;
  allowBackgroundPopupClose = false;
});

function eventTargetsPopup(originalEvent) {
  if (!originalEvent) return false;
  const classesToMatch = ['leaflet-popup', 'leaflet-popup-content', 'leaflet-popup-content-wrapper'];
  if (typeof originalEvent.composedPath === 'function') {
    const path = originalEvent.composedPath();
    if (Array.isArray(path)) {
      return path.some(node => {
        if (!node || !node.classList) return false;
        return classesToMatch.some(cls => node.classList.contains(cls));
      });
    }
  }
  let target = originalEvent.target || originalEvent.srcElement;
  while (target) {
    if (target.classList && classesToMatch.some(cls => target.classList.contains(cls))) {
      return true;
    }
    if (typeof target.closest === 'function') {
      const popupAncestor = target.closest('.leaflet-popup');
      if (popupAncestor) return true;
    }
    target = target.parentNode;
  }
  return false;
}

function handleBackgroundPopupClose(e) {
  if (!activePopup || !allowBackgroundPopupClose) {
    return;
  }
  const originalEvent = e.originalEvent || e;
  if (eventTargetsPopup(originalEvent)) {
    return;
  }
  allowBackgroundPopupClose = false;
  map.closePopup(activePopup);
}

map.on('click', handleBackgroundPopupClose);
map.on('touchstart', handleBackgroundPopupClose);
map.on('contextmenu', handleBackgroundPopupClose);


  // Create custom shape markers
  function createShapeMarker(latlng, color, shape, isIdeal = false, isCultivar = false) {
    const svgShapes = {
      circle: `<circle cx="12" cy="12" r="8" fill="${color}" stroke="white" stroke-width="2"/>`,
      square: `<rect x="6" y="6" width="12" height="12" fill="${color}" stroke="white" stroke-width="2"/>`,
      triangle: `<polygon points="12,4 20,18 4,18" fill="${color}" stroke="white" stroke-width="2"/>`,
      pentagon: `<polygon points="12,3 21,9 18,19 6,19 3,9" fill="${color}" stroke="white" stroke-width="2"/>`,
      diamond: `<polygon points="12,2 22,12 12,22 2,12" fill="${color}" stroke="white" stroke-width="2"/>`,
      star: `<polygon points="12,2 14.5,9 22,9 16,14 18,22 12,17 6,22 8,14 2,9 9.5,9" fill="${color}" stroke="white" stroke-width="2"/>`,
      starLarge: `<polygon points="12,2 14.5,9 22,9 16,14 18,22 12,17 6,22 8,14 2,9 9.5,9" fill="${color}" stroke="white" stroke-width="2.5"/>`
    };
    
    // Use star shape for ideal age trees
    let finalShape = isIdeal ? 'star' : shape;
    let iconSize = [24, 24];
    
    // Wild-type (native) in ideal age: larger black star
    if (isIdeal && !isCultivar) {
      finalShape = 'starLarge';
      iconSize = [30, 30]; // Bigger for wild-type
      color = '#000000'; // Black for wild-type
    } else if (isIdeal && isCultivar) {
      // Cultivar in ideal age: keep purple star at normal size
      color = '#8b4789'; // Purple for all cultivars
    }
    
    const svgIcon = L.divIcon({
      html: `<svg width="${iconSize[0]}" height="${iconSize[1]}" viewBox="0 0 24 24">${svgShapes[finalShape] || svgShapes.circle}</svg>`,
      className: 'custom-marker',
      iconSize: iconSize,
      iconAnchor: [iconSize[0]/2, iconSize[1]/2]
    });
    
    return L.marker(latlng, { icon: svgIcon });
  }

  // layer to hold current WFS features
  let wfsLayer = L.geoJSON(null, {
    onEachFeature(feature, layer) {
      const props = feature.properties || {};
      layer.bindPopup(buildPopup(props), {
        autoClose: true,
        closeButton: true,
        closeOnClick: false,
        className: 'sticky-popup'
      });
      
      // Store feature data for filtering
      layer.feature = feature;
      layer.__searchText = buildSearchString(props);
      layer.__presentation = buildSearchPresentation(props);
      if (!layer.__featureKey) {
        const latlng = typeof layer.getLatLng === 'function' ? layer.getLatLng() : null;
        layer.__featureKey = getFeatureKey(props, latlng);
      }

      layer.on('popupopen', () => {
        const latlng = typeof layer.getLatLng === 'function' ? layer.getLatLng() : null;
        activeFeatureKey = layer.__featureKey || getFeatureKey(props, latlng);
      });

      layer.on('popupclose', () => {
        if (suppressActiveFeatureReset) {
          return;
        }
        const latlng = typeof layer.getLatLng === 'function' ? layer.getLatLng() : null;
        const key = layer.__featureKey || getFeatureKey(props, latlng);
        if (key && key === activeFeatureKey) {
          activeFeatureKey = null;
        }
      });
    },
    pointToLayer(feature, latlng) {
      const props = feature.properties || {};
      const truffleSpecies = getTruffleSpecies(props);
      
      if (truffleSpecies) {
        // Check if tree is in ideal age range
        const age = getTreeAge(props);
        const ideal = isIdealAge(truffleSpecies, age);
        
        // Truffle-compatible species: custom shape marker with species color
        // Use star shape if in ideal age range
        // Wild-type (native) gets black star, cultivars get purple star
        const marker = createShapeMarker(latlng, truffleSpecies.color, truffleSpecies.shape, ideal, truffleSpecies.isCultivar);
        marker._defaultOpacity = (marker.options && typeof marker.options.opacity === 'number') ? marker.options.opacity : 1;
        marker.__featureKey = getFeatureKey(props, latlng);
        return marker;
      } else {
        // Default: faint grey circle marker for all other trees
        const circle = L.circleMarker(latlng, { 
          radius: 5, 
          fillColor: '#cccccc', 
          color: '#999999', 
          weight: 1, 
          fillOpacity: 0.4 
        });
        circle._defaultOpacity = (circle.options && typeof circle.options.opacity === 'number') ? circle.options.opacity : 1;
        circle._defaultStyle = {
          radius: circle.options.radius,
          fillColor: circle.options.fillColor,
          color: circle.options.color,
          weight: circle.options.weight,
          fillOpacity: circle.options.fillOpacity,
          opacity: typeof circle.options.opacity === 'number' ? circle.options.opacity : 1
        };
        circle.__featureKey = getFeatureKey(props, latlng);
        return circle;
      }
    }
  }).addTo(map);

  // ---------- HELPERS ----------
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function debounce(fn, ms){
    let t;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  // Truffle-compatible species detection and color mapping with ideal age ranges
  const TRUFFLE_SPECIES = {
    // Oak (Eiche) - Circle - ideal: 30-80 years; match all Quercus species via prefix
    'Quercus': { color: '#8b4789', name: 'Oak', shape: 'circle', order: 1, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    // Hazel (Hasel) - Square - ideal: 15-30 years
    'Corylus avellana': { color: '#4575b4', name: 'Hazel', shape: 'square', order: 2, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 15, maxAge: 30 },
    // Beech (Buche) - Triangle - ideal: 30-80 years
    'Fagus sylvatica': { color: '#1a9850', name: 'Beech', shape: 'triangle', order: 3, truffles: ['aestivum', 'uncinatum'], minAge: 30, maxAge: 80 },
    // Hornbeam (Hainbuche) - Pentagon - ideal: 30-80 years
    'Carpinus betulus': { color: '#d95f02', name: 'Hornbeam', shape: 'pentagon', order: 4, truffles: ['aestivum', 'uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    // Linden (Linde) - Diamond - ideal: 30-80 years
    'Tilia cordata': { color: '#fee08b', name: 'Linden', shape: 'diamond', order: 5, truffles: ['uncinatum', 'brumale'], minAge: 30, maxAge: 80 },
    'Tilia platyphyllos': { color: '#fee08b', name: 'Linden', shape: 'diamond', order: 5, truffles: ['uncinatum', 'brumale'], minAge: 30, maxAge: 80 }
  };
  
  function isCultivar(latinName) {
    // Check if the name contains cultivar indicators (quotes, 'cv.', 'var.', etc.)
    return latinName.includes("'") || latinName.includes('"') || 
           latinName.includes('cv.') || latinName.includes('var.') ||
           latinName.includes('cultivar') || latinName.includes('subsp.');
  }

  function getTruffleSpecies(props) {
    if (!props || !props.baumnamelat) return null;
    const latinName = props.baumnamelat.trim();
    
    // Check for exact match first
    if (TRUFFLE_SPECIES[latinName]) {
      const speciesInfo = { ...TRUFFLE_SPECIES[latinName] };
      speciesInfo.isCultivar = false;
      return speciesInfo;
    }
    
    // Check if latin name starts with any of our species (handles cultivars)
    for (const [species, info] of Object.entries(TRUFFLE_SPECIES)) {
      if (latinName.startsWith(species)) {
        const speciesInfo = { ...info };
        speciesInfo.isCultivar = isCultivar(latinName);
        return speciesInfo;
      }
    }
    
    return null;
  }
  
  function getTreeAge(props) {
    if (!props || !props.pflanzjahr) return null;
    const plantYear = parseInt(props.pflanzjahr);
    if (isNaN(plantYear) || plantYear <= 0) return null;
    return new Date().getFullYear() - plantYear;
  }
  
  function isIdealAge(truffleSpecies, age) {
    if (!truffleSpecies || age === null) return false;
    return age >= truffleSpecies.minAge && age <= truffleSpecies.maxAge;
  }
  
  function fmtValue(value){
    if (value === null || value === undefined || value === '') return '‚Äî';
    return escapeHtml(String(value));
  }

  // Truffle species info with seasons
  const TRUFFLE_INFO = {
    'aestivum': { name: 'Tuber aestivum', common: 'Summer truffle', months: 'May-Sep' },
    'uncinatum': { name: 'Tuber uncinatum', common: 'Burgundy/Autumn truffle', months: 'Sep-Dec' },
    'brumale': { name: 'Tuber brumale', common: 'Winter black truffle', months: 'Nov-Mar' }
  };

  const SUMMARY_FIELDS = [
    { key: 'baumnummer', label: 'Baumnummer' },
    { key: 'baumnamelat', label: 'Latin name' },
    { key: 'baumnamedeu', label: 'German name' },
  { key: 'kronendurchmesser', label: 'Kronendurchm.' },
    { key: 'pflanzjahr', label: 'Pflanzjahr' }
  ];

  function getFeatureKey(props, latlng) {
    if (!props) return null;
    if (props.baumnummer) {
      return `baumnummer:${props.baumnummer}`;
    }
    if (props.objectid) {
      return `objectid:${props.objectid}`;
    }
    if (latlng && typeof latlng.lat === 'number' && typeof latlng.lng === 'number') {
      return `coord:${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`;
    }
    return null;
  }

  function buildSearchString(props) {
    if (!props) return '';
    const parts = [];
    for (const { key } of SUMMARY_FIELDS) {
      const value = props[key];
      if (value === null || value === undefined || value === '') continue;
      parts.push(String(value).toLowerCase());
    }
    return parts.join(' ');
  }

  function buildSearchPresentation(props) {
    const latin = props && props.baumnamelat ? String(props.baumnamelat).trim() : '';
    const german = props && props.baumnamedeu ? String(props.baumnamedeu).trim() : '';
    const treeId = props && props.baumnummer ? String(props.baumnummer).trim() : '';
    let title = latin || german || (treeId ? `Baumnummer ${treeId}` : 'Tree');
    let subtitle = '';
    if (german && german !== title) {
      subtitle = german;
    } else if (latin && latin !== title) {
      subtitle = latin;
    } else if (treeId) {
      subtitle = `Baumnummer ${treeId}`;
    } else if (props && props.kronendurchmesser) {
      subtitle = `Kronendurchmesser ${props.kronendurchmesser} m`;
    }
    if (subtitle && subtitle === title) {
      subtitle = '';
    }
    return { title, subtitle };
  }

  function reopenActivePopup() {
    if (!activeFeatureKey) return;
    let reopened = false;
    wfsLayer.eachLayer((layer) => {
      if (reopened) return;
      const latlng = typeof layer.getLatLng === 'function' ? layer.getLatLng() : null;
      const key = layer.__featureKey || getFeatureKey(layer.feature && layer.feature.properties, latlng);
      if (key && key === activeFeatureKey && typeof layer.openPopup === 'function') {
        layer.openPopup();
        reopened = true;
      }
    });
    if (!reopened) {
      activeFeatureKey = null;
    }
  }

  function clearSearchResults() {
    lastSearchMatches.clear();
    if (searchResults) {
      searchResults.innerHTML = '';
      searchResults.classList.remove('show');
    }
    applySearchFilter(null);
    reopenActivePopup();
  }

  function renderSearchResults(matches, truncated) {
    if (!searchResults) return;
    if (!matches.length) {
      searchResults.innerHTML = '<div class="search-empty">No matches in current view</div>';
      searchResults.classList.add('show');
      return;
    }
    const itemsHtml = matches.map(({ id, title, subtitle }) => {
      const subtitleHtml = subtitle ? `<div class="search-result-subtitle">${escapeHtml(subtitle)}</div>` : '';
      return `<button type="button" class="search-result" data-layer-id="${escapeHtml(id)}"><div class="search-result-title">${escapeHtml(title)}</div>${subtitleHtml}</button>`;
    }).join('');
    const noteHtml = truncated ? '<div class="search-info">Showing first matches only. Refine your search to narrow results.</div>' : '';
    searchResults.innerHTML = itemsHtml + noteHtml;
    searchResults.classList.add('show');
  }

  function showLayer(layer) {
    if (!layer) return;
    if (typeof layer.setOpacity === 'function') {
      const defaultOpacity = typeof layer._defaultOpacity === 'number' ? layer._defaultOpacity : 1;
      layer.setOpacity(defaultOpacity);
    }
    if (typeof layer.setStyle === 'function' && layer._defaultStyle) {
      layer.setStyle(layer._defaultStyle);
    }
    const el = typeof layer.getElement === 'function' ? layer.getElement() : null;
    if (el) {
      el.style.display = '';
    }
  }

  function hideLayer(layer) {
    if (!layer) return;
    if (typeof layer.setOpacity === 'function') {
      layer.setOpacity(0);
    }
    if (typeof layer.setStyle === 'function' && layer._defaultStyle) {
      const hiddenStyle = { ...layer._defaultStyle, opacity: 0, fillOpacity: 0 };
      layer.setStyle(hiddenStyle);
    }
    const el = typeof layer.getElement === 'function' ? layer.getElement() : null;
    if (el) {
      el.style.display = 'none';
    }
  }

  function applySearchFilter(matchIds) {
    const hasFilter = Array.isArray(matchIds);
    const matchSet = hasFilter ? new Set(matchIds) : null;
    wfsLayer.eachLayer((layer) => {
      const id = String(L.stamp(layer));
      const latlng = typeof layer.getLatLng === 'function' ? layer.getLatLng() : null;
      const key = layer.__featureKey || getFeatureKey(layer.feature && layer.feature.properties, latlng);
      if (!hasFilter || matchSet.has(id)) {
        showLayer(layer);
      } else {
        hideLayer(layer);
        if (key && key === activeFeatureKey) {
          activeFeatureKey = null;
          if (typeof layer.closePopup === 'function') {
            layer.closePopup();
          } else {
            map.closePopup();
          }
        }
      }
    });
  }

  function updateSearchResults() {
    if (!searchInput || !searchResults) return;
    const query = searchInput.value.trim().toLowerCase();
    if (!query) {
      clearSearchResults();
      return;
    }

    const bounds = map.getBounds();
    const layers = wfsLayer.getLayers();
    const matchesForDisplay = [];
    const matchingIds = [];
    lastSearchMatches.clear();

    for (const layer of layers) {
      if (typeof layer.getLatLng !== 'function') continue;
      const latlng = layer.getLatLng();
      if (!bounds.contains(latlng)) continue;
      const props = layer.feature && layer.feature.properties;
      if (!props) continue;
      const searchText = layer.__searchText || buildSearchString(props);
      if (!searchText || !searchText.includes(query)) continue;
      const id = String(L.stamp(layer));
      matchingIds.push(id);
      if (matchesForDisplay.length < SEARCH_RESULTS_LIMIT) {
        const presentation = layer.__presentation || buildSearchPresentation(props);
        matchesForDisplay.push({ id, title: presentation.title, subtitle: presentation.subtitle });
        lastSearchMatches.set(id, { layer, latlng });
      }
    }

    const truncated = matchingIds.length > SEARCH_RESULTS_LIMIT;
    renderSearchResults(matchesForDisplay, truncated);
    applySearchFilter(matchingIds);
    reopenActivePopup();
  }

  function buildPopup(props){
    const summaryGrid = SUMMARY_FIELDS.map(({ key, label }) => {
      let val = props && (key in props) ? props[key] : '‚Äî';
      if (key === 'kronendurchmesser' && val !== '‚Äî') {
        val = `${val} m`;
      }
      return `
        <div class="popup-summary-item">
          <div class="popup-summary-label">${escapeHtml(label)}</div>
          <div class="popup-summary-value">${fmtValue(val)}</div>
        </div>`;
    }).join('');

    // Check if this is a truffle-compatible species
    const truffleSpecies = getTruffleSpecies(props);
    let truffleInfo = '';
    
    if (truffleSpecies && truffleSpecies.truffles && truffleSpecies.truffles.length > 0) {
      const truffleList = truffleSpecies.truffles.map(t => {
        const info = TRUFFLE_INFO[t];
        return `<div><em>${escapeHtml(info.name)}</em><span>(${escapeHtml(info.months)})</span></div>`;
      }).join('');
      
      // Calculate age and check if ideal
      const age = getTreeAge(props);
      const ideal = isIdealAge(truffleSpecies, age);
      const ageText = age !== null ? `${age} years old` : 'unknown age';
      const ageRangeText = `${truffleSpecies.minAge}-${truffleSpecies.maxAge} years`;
      
      let ageStatus = '';
      if (age !== null) {
        if (ideal) {
          if (truffleSpecies.isCultivar) {
            ageStatus = `<div class="popup-age popup-age--cultivar">
              ‚≠ê <strong>Ideal age for truffles</strong> (${escapeHtml(ageText)}, ideal: ${escapeHtml(ageRangeText)})
              <small>‚ö†Ô∏è Cultivar: less optimal than wild-type for truffle production</small>
            </div>`;
          } else {
            ageStatus = `<div class="popup-age popup-age--optimal">
              ‚≠ê <strong>OPTIMAL for truffles!</strong> (${escapeHtml(ageText)}, ideal: ${escapeHtml(ageRangeText)})
              <small>‚úì Wild-type / Native species</small>
            </div>`;
          }
        } else {
          const cultivarNote = truffleSpecies.isCultivar ? '<small>Note: Cultivar variety</small>' : '';
          ageStatus = `<div class="popup-age popup-age--warning">
            Age: ${escapeHtml(ageText)} (ideal: ${escapeHtml(ageRangeText)})
            ${cultivarNote}
          </div>`;
        }
      }
      
      truffleInfo = `
        <div class="popup-truffle">
          <div class="popup-truffle-title">üçÑ Truffle Host</div>
          <div class="popup-truffle-list">${truffleList}</div>
          ${ageStatus}
        </div>`;
    }

    return `
      <div>
        <div class="popup-summary-grid">${summaryGrid}</div>
        ${truffleInfo}
      </div>`;
  }

  // Build WFS GetFeature URL for the current bbox. For WFS 1.1.0 bbox order is minx,miny,maxx,maxy
  function buildWfsUrl(bboxStr){
    // bboxStr from Leaflet is "minLng,minLat,maxLng,maxLat"
    const params = new URLSearchParams({
      service: 'WFS',
      version: '1.1.0',
      request: 'GetFeature',
      typeName: WFS_TYPENAME,
      outputFormat: WFS_OUTPUT,
      srsName: WFS_SRS,
      bbox: bboxStr + ',' + WFS_SRS
    });
    return `${WFS_BASE}?${params.toString()}`;
  }

  // Load features for current map view
  async function loadFeaturesForView(){
    const bounds = map.getBounds();
    const bboxStr = bounds.toBBoxString(); // "minLng,minLat,maxLng,maxLat"
    const url = buildWfsUrl(bboxStr);
    updateStatus('Fetching trees for current view‚Ä¶', { sticky: true });
    try {
      const resp = await fetch(url, { cache: 'no-store' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      // server responds with GeoJSON when using application/vnd.geo+json
      const geojson = await resp.json();
      let featureCount = null;
      suppressActiveFeatureReset = true;
      try {
        wfsLayer.clearLayers();
      } finally {
        suppressActiveFeatureReset = false;
      }

      // If server returns features in a property other than "features", try to handle gracefully
      if (geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)) {
        wfsLayer.addData(geojson);
        featureCount = geojson.features.length;
      } else if (geojson.features && Array.isArray(geojson.features)) {
        wfsLayer.addData(geojson.features);
        featureCount = geojson.features.length;
      } else {
    // unexpected response; show raw
    warnOnce('unexpected-geojson', 'Unexpected GeoJSON shape', geojson);
        updateStatus('Loaded (unexpected response shape) ‚Äî check console', { type: 'error', sticky: true });
        clearSearchResults();
        reopenActivePopup();
        return;
      }

      if (featureCount !== null) {
        updateStatus(`Loaded ${featureCount} total trees`, { type: 'success' });
        if (hasActiveSearch()) {
          updateSearchResults();
        } else {
          clearSearchResults();
        }
      }
    } catch (err) {
      console.error('WFS fetch failed', err);
      updateStatus(`Failed to load WFS: ${escapeHtml(err.message)}<br><small>(Check console for details)</small>`, {
        type: 'error',
        allowHtml: true,
        sticky: true
      });
      clearSearchResults();
    }
  }

  const debouncedLoad = debounce(loadFeaturesForView, DEBOUNCE_MS);

  function hasActiveSearch() {
    return !!(searchInput && searchInput.value.trim());
  }

  function handleViewChange() {
    debouncedLoad();
    if (hasActiveSearch()) {
      updateSearchResults();
    }
  }

  // ---------- INITIAL LOAD & EVENTS ----------
  map.on('moveend', handleViewChange);

  // Load initial features after a short delay to ensure map is fully initialized
  setTimeout(loadFeaturesForView, 100);

  // Also allow zoom-to and reload by double-clicking the status box (handy for dev)
  statusEl.title = 'Double-click to reload WFS for current view';
  statusEl.ondblclick = () => loadFeaturesForView();

  // ---------- INFO MODAL ----------
  const infoButton = document.getElementById('infoButton');
  const infoModal = document.getElementById('infoModal');
  const closeButton = document.getElementById('closeButton');

  infoButton.onclick = () => {
    infoModal.classList.add('show');
  };

  closeButton.onclick = () => {
    infoModal.classList.remove('show');
  };

  // Close modal when clicking outside content
  infoModal.onclick = (e) => {
    if (e.target === infoModal) {
      infoModal.classList.remove('show');
    }
  };

  // ---------- LOCATE BUTTON ----------
  const locateButton = document.getElementById('locateButton');

  locateButton.onclick = () => {
    if (locateRequested) {
      return;
    }
    locateRequested = true;
    locateButton.textContent = '‚è≥';

    if (locateResetTimer) {
      clearTimeout(locateResetTimer);
      locateResetTimer = null;
    }

    try {
      map.locate({
        setView: false,
        enableHighAccuracy: true,
        timeout: GEO_TIMEOUT_MS,
        watch: false
      });
    } catch (err) {
      locateRequested = false;
      locateButton.textContent = 'üìç';
      updateStatus('Geolocation is not supported in this browser.', { type: 'error', sticky: true });
      warnOnce('locate-unsupported', err.message || 'Geolocation unsupported');
      return;
    }
    
    locateResetTimer = setTimeout(() => {
      if (locateButton.textContent === '‚è≥') {
        locateButton.textContent = 'üìç';
      }
      locateRequested = false;
    }, GEO_TIMEOUT_MS + 1000);
  };

  if (searchInput) {
    searchInput.addEventListener('input', () => {
      debouncedUpdateSearch();
    });

    searchInput.addEventListener('focus', () => {
      if (hasActiveSearch()) {
        updateSearchResults();
      }
    });

    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        searchInput.value = '';
        clearSearchResults();
        searchInput.blur();
      }
    });
  }

  if (searchResults) {
    searchResults.addEventListener('click', (e) => {
      const target = e.target.closest('[data-layer-id]');
      if (!target) return;
      const id = target.getAttribute('data-layer-id');
      if (!id) return;
      const match = lastSearchMatches.get(id);
      if (!match) return;
      const desiredZoom = map.getZoom() < 17 ? 17 : map.getZoom();
      map.setView(match.latlng, desiredZoom, { animate: true });
      if (match.layer && typeof match.layer.openPopup === 'function') {
        match.layer.openPopup();
      }
      searchResults.classList.remove('show');
    });
  }

  if (searchContainer && searchResults) {
    document.addEventListener('click', (e) => {
      if (!searchContainer.contains(e.target)) {
        searchResults.classList.remove('show');
      }
    });
  }

  </script>
</body>
</html>